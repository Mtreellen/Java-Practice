复习：

**final修饰的类不能被继承只是表示不能被extends，但是子类继承了父类的final修饰的内部类**

<font color="red">只能用不能改！！！</font>

```java
class Outter{
    private String name = "test";
    
    final class Inner {
        public void fun() {
            System.out.println(name);
        }
    }
}

class Child extends Outter {
    //Inner类有没有被继承下来？？——继承了
    public void test() {
        Inner in = new Inner();
        in.fun();
    }
}

public class Test7_21 {
    public static void main(String[] args) {
        Child child = new Child();
        child.test();
    }
}
```

简单工厂：Spring-BeanFactory

- 抽象产品类
- 多个具体产品类
- 一个工厂类



工厂方法模式：Spring-FactoryBean

- 抽象产品类
- 多个具体产品类
- 一个抽象工厂接口
- 多个具体产品类

## 代理模式

特点：两个子类共同实现同一个接口，其中一个子类负责真实业务实现，另一个子类完成辅助真实业务主题的操作。

例子：

​	玩游戏—接口														买口红—接口

​	真实主题类：人													真实主题类：人

​	代理类：代练														代理类：代购

```java
//主题subject
interface ISubject {
    void buyLipstick();
}

//真实主题类
class RealSubject implements ISubject {
    public void buyLipstick() {
        System.out.println("买Mac口红");
    }
}

class ProxySubject implements ISubject {
    //代理需要知道真实客户
    private ISubject realSubject;
    public ProxySubject(ISubject realSubject) {
        this.realSubject = realSubject;
    }
    public void beforeBuy() {
        System.out.println("取钱，排队");
    }
    public void afterBuy() {
        System.out.println("发货，验收");
    }
    public void buyLipstick() {
        //辅助操作
        this.beforeBuy();

        //真实操作
        this.realSubject.buyLipstick();
        
        //辅助操作
        this.afterBuy();
    }
}

public class Test7_21 {
    public static void main(String[] args) {
       ISubject subject = new ProxySubject(new RealSubject());
       subject.buyLipstick();
    }
}
```

![](D:\笔记\Java4录屏笔记\图\代理模式类图.png)

 **代理模式的定义：**代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。