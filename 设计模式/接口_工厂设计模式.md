## 接口

接口有限原则：在一个操作既可以使用抽象类又可以使用接口时，优先考虑接口。

#### 1、接口定义（JDK8以前）

接口就是**<font color="red">抽象方法</font>**与**<font color="red">全局常量</font>**的集合***（纯粹版的抽象类）***

```java
interface IMyInterface {
    //全局常量
    public static final String msg = "test";
    //抽象方法
    public abstract void test();
}
```

**interface关键字定义接口**

接口命名规范：为了区分接口和类，在接口命名时**在名字前面加上I（大写I）**

##### 1.1 子类实现父类

​	子类要实现接口用implements关键字，一个子类可以同时<font color="red">实现</font>多个接口（避免了单继承局限）

​		——接口优先原则

​	子类的命名规范：接口名为**IMyInterface**，则子类实现此接口命名为 **MyInterfaceImpl**

```java
interface IMyInterface {
    //全局常量
    	//static修饰的变量位于全局数据区
    public static final String msg = "test";
    //抽象方法
    public abstract void test();
}

interface IMessage {
    public abstract void getMsg();
}

//子类实现接口
class MyInterfaceImpl implements IMyInterface , IMessage {
    //覆写IMyInterface接口抽象方法
    public void test() {
        System.out.println(msg);
    }

    //覆写IMessage接口抽象方法
    public void getMsg() {
        System.out.println(msg);
    }

}
public class Test6_27 {
    public static void main(String[] args) {
        //向上转型
        IMyInterface myInterface = new MyInterfaceImpl();
        //父类接口间的相互转换
        IMessage message = (IMessage) myInterface;
        message.getMsg();
    }
}
```

##### 2.1 父接口之间的相互转换

**父接口间的相互转换前提：两个父接口拥有共同的实现子类。**



#### 2、接口的使用限制*************

##### 2.1 权限修饰符

接口中只允许public权限（常量、方法都是public）

**【接口中不写权限修饰符，默认是public】**

**阿里编码规约：接口中不要出现任何访问修饰符：public也不要**

```java
interface IMyInterface {
    //全局常量
    static final String msg = "test";
    //抽象方法
    abstract void test();
}

class MyInterfaceImpl implements IMyInterface {
    //覆写抽象方法
    public void test() {
        System.out.println(msg);
    }
}
public class Test6_27 {
    public static void main(String[] args) {
        //向上转型
        IMyInterface myInterface = new MyInterfaceImpl();
        myInterface.test();
    }
}
```

PS：类中方或者属性不写权限修饰符表示default；但是接口中默认是public权限。

##### 2.2 顺序

当子类既需要实现接口又需要继承抽象类时，先使用extends继承一个抽象类，而后使用implements实现多个接口。

```java
 public static void main(String[] args) {
        IMyInterface myInterface = new MyInterfaceImpl();
        myInterface.test();
        News news = new MyInterfaceImpl();
        news.fun();
    }
```

```java
IMyInterface myInterface = new MyInterfaceImpl();
//与接口直接转换比较
News news = (News) myInterface;
news.fun();
```

##### 2.3 抽象类实现接口

​		抽象类可以使用implements实现多个接口【普通类能做的事抽象类都可以，除了生成实例_MY】

**接口不能继承抽象类。**

​		接口中只有抽象方法和全局常量，抽象类中除了抽象方法还有普通方法等。。

```java
interface IMyInterface {
    //全局常量
    static final String msg = "test";
    //抽象方法
    abstract void test();
}

//抽象类实现接口
abstract class News implements IMyInterface {
    public abstract void fun();
}

//普通类实现接口
class MyInterfaceImpl extends News {
    //class MyInterfaceImpl extends News implements IMyInterface {声明
    public void fun() {
        System.out.println(msg);
    }

    //覆写抽象方法
    public void test() {
        System.out.println(msg);
    }
}

public class Test6_27 {
    public static void main(String[] args) {
        IMyInterface myInterface = new MyInterfaceImpl();
        News news = (News) myInterface;
        news.fun();
    }
}
```

##### 2.4 接口多继承

​		接口可以使用**extends**继承多个**父接口**（接口多继承）

```java
interface IA {
    void test1();
}

interface IB {
    void test2();
}

interface IC extends IA,IB {
    void test3();
}



class DImpl implements IC {
    public void test1() {}
    public void test2() {}
    public void test3() {}
}

public class Test6_28 {
    public static void main(String[] args) {
        new DImpl();
    }
}
```

PS：以后再看：存在一个内部接口。。。。

#### 3、接口的应用

什么时候用抽象类？什么时候用接口？

抽象类：is-a

**接口应用场景：**

**（1）定义操作标准**

**（2）表示能力**

**（3）分布式开发之中暴露远程服务方法**

```java
interface USB {
    void plugin();
    void setup();
    void work();
}

class Mouse implements USB {
    public void plugin() {
        System.out.println("鼠标插入电脑");
    }

    public  void setup() {
        System.out.println("鼠标安装驱动");
    }

    public void work() {
        System.out.println("鼠标正常工作");
    }
}

class KeyBoard implements USB {
    public void plugin() {
        System.out.println("键盘插入电脑");
    }

    public void setup() {
        System.out.println("键盘安装驱动");
    }

    public void work() {
        System.out.println("键盘正常工作");
    }
}

class Computer {
    //参数是接口，向上转型
    //参数统一化
    public void useUsbDevices(USB usb) {
        usb.plugin();
        usb.setup();
        usb.work();
    }
}

public class Test6_28 {
    public static void main(String[] args) {
        Computer computer = new Computer();
        
        computer.useUsbDevices(new Mouse());
        computer.useUsbDevices(new KeyBoard());
    }
}
```

## 工厂设计模式

掌握三种重点设计模式：工厂、单例、代理

```java
interface Computer {
    void printComputer();
}

class MacbookPro implements Computer {

    public void printComputer() {
        System.out.println("This is a MacbookPro with Touch Bar");
    }
}

class SurfaceBook implements Computer {
    public void printComputer() {
        System.out.println("This is a SurfaceBook");
    }
}
public class Test7_19 {
    //客户端
    public static void main(String[] args) {

        Computer com = new MacbookPro();
        com.printComputer();
    }
}
```

如果此时要加入一个牌子的笔记本Alienware（外星人），就需要在上面的客户端代码部分进行修改，让客户端支持Alienware笔记本；那么，如何将实例化具体类的代码从客户端中抽离，或者封装起来，使它们不会干扰应用的其他部分呢？

### 工厂设计模式

——将客户端的 new 操作解耦到第三方（即工厂）

#### 1、简单工厂设计模式

——产品个数少且没有家族。

##### 1.1 简单工厂的特点

- 一个抽象产品类（接口）

- 多个具体产品类——MacbookPro、SurfaceBook

  main(

  ​	Computer computer = ComputerFactory.printComputer();

  )

- 一个工厂（new操作在此工厂中进行）——客户端通过工厂获取实例

```java
import java.util.Scanner;

interface Computer {
    void printComputer();
}

class MacbookPro implements Computer {

    public void printComputer() {
        System.out.println("This is a MacbookPro with Touch Bar");
    }
}

class SurfaceBook implements Computer {
    public void printComputer() {
        System.out.println("This is a SurfaceBook");
    }
}

class Alienware implements Computer {
    public void printComputer() {
        System.out.println("This is a Alienware");
    }
}

//简单工厂
//将所有产生Computer对象实例的操作解耦到工厂类中
class ComputerFactory {
    //将构造方法修饰为private，使得类的外部不能产生对象
    private ComputerFactory() {}

    public static Computer getInstance(String str) {
        Computer computer = null;
        if(str.equals("mac")) {
            computer = new MacbookPro();
        }else if(str.equals("surface")) {
            computer = new SurfaceBook();
        }else if (str.equals("alienware")){
            computer = new Alienware();
        }
        return computer;
    }
}
public class Test7_19 {
    //客户端
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入电脑型号：");
        String type = scanner.nextLine();
        Computer com = ComputerFactory.getInstance(type);
        com.printComputer();
    }
}
```

![](D:\笔记\Java4录屏笔记\图\简单工厂类图.png)

#### 2、工厂方法模式

——每个产品有自己的家族，家族下有很多兄弟。

改良简单工厂模式版本

**定义一个用来创建对象的接口，让子类决定实例化哪一个类。**

针对每个产品（产品族）提供一个工厂类，客户端需要判断使用哪个工厂。

![](D:\笔记\Java4录屏笔记\图\工厂设计模式类图.png)

```java
interface Computer {
    void printComputer();
}

class MacbookPro implements Computer {
    public void printComputer() {
        System.out.println("This is a MacbookPro with Touch Bar");
    }
}

class SurfaceBook implements Computer {
    public void printComputer() {
        System.out.println("This is a SurfaceBook");
    }
}

class Alienware implements Computer {
    public void printComputer() {
        System.out.println("This is a Alienware");
    }
}

//抽象工厂类
interface ComputerFactory {
    //返回值Computer对象，名为createComputer()
    Computer createComputer();//public  Computer createComputer(只是接口中不能写权限而已修饰符)
}

class MsFactory implements ComputerFactory {
    public Computer createComputer() {
        return new SurfaceBook();
    }
}

class AppleFactory implements ComputerFactory {
    public Computer createComputer() {
        return new MacbookPro();
    }
}

public class Test7_21 {
    //客户端
    public static void main(String[] args) {

      ComputerFactory factory = new AppleFactory();
      
      Computer computer = factory.createComputer();
      
      computer.printComputer();
    }
}
```

##### 2.1 工厂方法模式特点

1）一个抽象产品类

2）多个具体产品类

3）一个抽象工厂（针对抽象产品类）

4）多个具体工厂（每个产品家族拥有自己的工厂）

> <font color="red">工厂方法模式，横向扩展方便。</font>

## 抽象工厂（了解）

——多个产品线混合，产品线的组合。





